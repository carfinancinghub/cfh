/*
File: insuranceIntegrationService.test.ts
Path: C:\CFH\backend\tests\services\integrations\insuranceIntegrationService.test.ts
Created: 2025-07-04 13:40 PDT
Author: Mini (AI Assistant)
Version: 1.0
Description: Jest test file for insuranceIntegrationService with skeleton tests.
Artifact ID: y4z5a6b7-c8d9-e0f1-g2h3-i4j5k6l7m8n9
Version ID: z5a6b7c8-d9e0-f1g2-h3i4-j5k6l7m8n9o0
*/

import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';
import logger from '@/utils/logger';
import { insuranceIntegrationService, InsuranceIntegrationServiceError } from '@/backend/services/integrations/insuranceIntegrationService';
import * as crypto from 'crypto'; // Import the actual crypto module
import { retryWithBackoff } from '@/utils/retryWithBackoff'; // Import the utility to mock

// Mock external dependencies
jest.mock('@/utils/logger', () => ({
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
}));

// Mock crypto.createHmac and crypto.timingSafeEqual for signature verification
jest.mock('crypto', () => ({
    ...jest.requireActual('crypto'), // Keep actual implementations for other crypto functions if needed
    createHmac: jest.fn(() => ({
        update: jest.fn().mockReturnThis(),
        digest: jest.fn(),
    })),
    timingSafeEqual: jest.fn(),
    randomUUID: jest.fn(() => 'mock-uuid-v4'), // Mock randomUUID for correlationId consistency
}));

// Mock the retry utility
jest.mock('@/utils/retryWithBackoff', () => ({
    retryWithBackoff: jest.fn(),
}));

// Mock estimateService methods that `insuranceIntegrationService` calls
jest.mock('@/backend/services/bodyshop/estimateService', () => ({
    estimateService: {
        findEstimateByClaimId: jest.fn(),
        findEstimateByVin: jest.fn(),
        updateEstimateFromInsuranceClaim: jest.fn(),
    },
}));

describe('insuranceIntegrationService', () => {
    let service: typeof insuranceIntegrationService;
    const mockWebhookSecret = 'mock-insurance-webhook-secret-from-secure-config'; // Needs to match the service's mock config

    const validClaimDataLinkedByClaimId = { claimId: 'mock-linked-claim', insuredVehicle: { make: 'A', model: 'B', vin: 'MOCKVIN123456789' } };
    const validClaimDataLinkedByVin = { claimId: 'another-claim', insuredVehicle: { make: 'X', model: 'Y', vin: 'MOCKVIN123456789' } };
    const validClaimDataUnlinked = { claimId: 'unlinked-claim', insuredVehicle: { make: 'C', model: 'D', vin: 'UNLINKEDVIN12345' } };
    const mockRawBody = JSON.stringify(validClaimDataLinkedByClaimId);
    const mockSignature = 'sha256=mock-digest'; // This will be generated by our mock Hmac


    beforeEach(() => {
        // Reset mocks before each test
        jest.clearAllMocks();
        // Ensure crypto.timingSafeEqual returns true by default for valid signatures
        (crypto.timingSafeEqual as jest.Mock).mockReturnValue(true);
        // Ensure createHmac.digest returns the mock digest
        (crypto.createHmac as jest.Mock).mockReturnValue({
            update: jest.fn().mockReturnThis(),
            digest: jest.fn().mockReturnValue('mock-digest'),
        });

        // Mock the retryWithBackoff utility's default behavior to just execute the function
        (retryWithBackoff as jest.Mock).mockImplementation(async (fn, maxAttempts, delays, correlationId) => {
            return await fn(); // Just run the function immediately
        });

        // Re-initialize service to pick up fresh mocks
        service = new (insuranceIntegrationService as any).constructor();

        // Mock internal estimateService calls for linked/unlinked scenarios
        (estimateService.findEstimateByClaimId as jest.Mock).mockImplementation(async (claimId: string) => {
            if (claimId === 'mock-linked-claim') return { id: 'mock-estimate-id-by-claim', status: 'Pending' };
            return null;
        });
        (estimateService.findEstimateByVin as jest.Mock).mockImplementation(async (vin: string) => {
            if (vin === 'MOCKVIN123456789') return { id: 'mock-estimate-id-by-vin', status: 'Pending' };
            return null;
        });
        (estimateService.updateEstimateFromInsuranceClaim as jest.Mock).mockResolvedValue(true);

        // Mock setTimeout to run immediately for performance checks
        jest.spyOn(global, 'setTimeout').mockImplementation((cb: any) => cb());
        jest.spyOn(global, 'clearTimeout').mockImplementation(() => {});
    });

    afterEach(() => {
        (global.setTimeout as jest.Mock).mockRestore();
        (global.clearTimeout as jest.Mock).mockRestore();
    });

    // --- processInsuranceWebhook Tests ---
    describe('processInsuranceWebhook', () => {

        it('should process webhook with valid signature and linked estimate (by claimId)', async () => {
            const result = await service.processInsuranceWebhook(validClaimDataLinkedByClaimId, mockRawBody, mockSignature);

            expect(result.estimateLinked).toBe(true);
            expect(result.status).toBe('processed');
            expect(result.claimId).toBe(validClaimDataLinkedByClaimId.claimId);
            expect(result).toHaveProperty('correlationId', 'mock-uuid-v4');
            expect(logger.info).toHaveBeenCalledWith(expect.stringContaining(`[CID:mock-uuid-v4] Processing insurance webhook for claim: ${validClaimDataLinkedByClaimId.claimId}`));
            expect(logger.info).toHaveBeenCalledWith(expect.stringContaining(`[CID:mock-uuid-v4] Linked claim ${validClaimDataLinkedByClaimId.claimId} to estimate mock-estimate-id-by-claim. Updating estimate.`));
            expect(logger.info).toHaveBeenCalledWith(expect.stringContaining('AUDIT: [CID:mock-uuid-v4] Insurance webhook processed.'));
            expect(estimateService.findEstimateByClaimId).toHaveBeenCalledWith(validClaimDataLinkedByClaimId.claimId);
            expect(estimateService.updateEstimateFromInsuranceClaim).toHaveBeenCalledWith('mock-estimate-id-by-claim', validClaimDataLinkedByClaimId);
            expect(logger.warn).not.toHaveBeenCalled(); // No performance warning
        });

        it('should process webhook with valid signature and linked estimate (by VIN)', async () => {
            const result = await service.processInsuranceWebhook(validClaimDataLinkedByVin, JSON.stringify(validClaimDataLinkedByVin), mockSignature);

            expect(result.estimateLinked).toBe(true);
            expect(result.status).toBe('processed');
            expect(result.claimId).toBe(validClaimDataLinkedByVin.claimId);
            expect(logger.info).toHaveBeenCalledWith(expect.stringContaining(`[CID:mock-uuid-v4] Linked claim ${validClaimDataLinkedByVin.claimId} to estimate mock-estimate-id-by-vin. Updating estimate.`));
            expect(estimateService.findEstimateByClaimId).toHaveBeenCalledWith(validClaimDataLinkedByVin.claimId); // Still called first
            expect(estimateService.findEstimateByVin).toHaveBeenCalledWith(validClaimDataLinkedByVin.insuredVehicle.vin); // Then this
            expect(estimateService.updateEstimateFromInsuranceClaim).toHaveBeenCalledWith('mock-estimate-id-by-vin', validClaimDataLinkedByVin);
        });

        it('should process webhook with valid signature but unlinked estimate', async () => {
            const result = await service.processInsuranceWebhook(validClaimDataUnlinked, JSON.stringify(validClaimDataUnlinked), mockSignature);

            expect(result.estimateLinked).toBe(false);
            expect(result.status).toBe('processed_unlinked');
            expect(result.claimId).toBe(validClaimDataUnlinked.claimId);
            expect(logger.warn).toHaveBeenCalledWith(expect.stringContaining(`[CID:mock-uuid-v4] No matching estimate found for claim ${validClaimDataUnlinked.claimId}.`));
            expect(estimateService.updateEstimateFromInsuranceClaim).not.toHaveBeenCalled();
        });

        it('should throw InsuranceIntegrationServiceError for invalid signature', async () => {
            (crypto.timingSafeEqual as jest.Mock).mockReturnValue(false); // Simulate invalid signature

            await expect(service.processInsuranceWebhook(validClaimDataLinkedByClaimId, mockRawBody, 'invalid-signature')).rejects.toThrow(InsuranceIntegrationServiceError);
            await expect(service.processInsuranceWebhook(validClaimDataLinkedByClaimId, mockRawBody, 'invalid-signature')).rejects.toThrow('Invalid webhook signature.');
            expect(logger.warn).toHaveBeenCalledWith(expect.stringContaining('Webhook signature mismatch.'));
            expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Attempt 1/3 failed for claim'), expect.any(InsuranceIntegrationServiceError)); // Retry utility logs this
            expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Failed to process webhook for claim'), expect.any(InsuranceIntegrationServiceError)); // Final error
        });

        it('should retry on internal processing failure and succeed', async () => {
            // Mock retryWithBackoff to simulate 2 failures then success
            (retryWithBackoff as jest.Mock).mockImplementation(async (fn, maxAttempts, delays, correlationId) => {
                let attempts = 0;
                while (attempts < 2) { // Fail twice
                    attempts++;
                    throw new Error(`Simulated transient error on attempt ${attempts}`);
                }
                return await fn(); // Then succeed
            });

            const result = await service.processInsuranceWebhook(validClaimDataLinkedByClaimId, mockRawBody, mockSignature);
            
            expect(result.estimateLinked).toBe(true);
            expect(result.status).toBe('processed');
            expect(retryWithBackoff).toHaveBeenCalledTimes(1); // retryWithBackoff itself is called once
            expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Attempt 1/3 failed for claim'));
            expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Attempt 2/3 failed for claim'));
            expect(logger.error).not.toHaveBeenCalledWith(expect.stringContaining('Failed to process webhook for claim after 3 retries')); // Did not hit max retries
        });

        it('should throw InsuranceIntegrationServiceError if processing times out (3s)', async () => {
            // Mock setTimeout to reject the timeoutPromise immediately
            jest.spyOn(global, 'setTimeout').mockImplementation((cb: any, ms: number) => {
                if (ms === 3000) { // This is the timeout promise
                    cb(); // Immediately trigger timeout
                }
                return {} as any;
            });
            // Mock retryWithBackoff to just run the function, so the timeout can be tested
            (retryWithBackoff as jest.Mock).mockImplementation(async (fn, maxAttempts, delays, correlationId) => {
                return await fn();
            });

            await expect(service.processInsuranceWebhook(validClaimDataLinkedByClaimId, mockRawBody, mockSignature)).rejects.toThrow(InsuranceIntegrationServiceError);
            await expect(service.processInsuranceWebhook(validClaimDataLinkedByClaimId, mockRawBody, mockSignature)).rejects.toThrow('Webhook processing timed out after 3s');
            expect(logger.error).toHaveBeenCalledWith(expect.stringContaining('Final error processing webhook for claim'), expect.any(InsuranceIntegrationServiceError));
        });

        it('should log a warning if response time exceeds 500ms', async () => {
            // Mock setTimeout within the service to simulate a long operation
            jest.spyOn(global, 'setTimeout').mockImplementation((cb: any) => {
                // Simulate 600ms delay for the internal processing
                setTimeout(() => cb(), 600);
                return {} as any;
            });

            await service.processInsuranceWebhook(validClaimDataLinkedByClaimId, mockRawBody, mockSignature);
            expect(logger.warn).toHaveBeenCalledWith(expect.stringContaining('Webhook processing exceeded 500ms'));
        });
    });
});